---
title: "Practicum 1 DB"
output: html_notebook
---

```{r}
library(RMySQL)

db_user <- 'dbadmin'
db_password <- 'dos8JINT.kras8jaun'
db_name <- 'SandboxDB'
db_host <- 'cs5200-dbs.ctuc7sl6qeau.us-east-2.rds.amazonaws.com' # AWS Host
db_port <- 3306

mydb <- dbConnect(MySQL(), dbname = db_name, host = db_host, port = db_port,
                  user = db_user, password = db_password)
```

```{r}
dbListTables(mydb)
```

```{sql connection=mydb}
-- Turns off foreign key check
SET FOREIGN_KEY_CHECKS = 0;
```

```{sql connection=mydb}
-- Turns on foreign key check
SET FOREIGN_KEY_CHECKS = 1;
```

# Creating the tables

## CREATE TABLE: Aircraft

```{sql connection=mydb}
DROP TABLE IF EXISTS Aircraft;
```

```{sql connection=mydb}
CREATE TABLE Aircraft(
  a_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  aircraft_name VARCHAR(255) NOT NULL,
  aircraft_type ENUM('aircraft', 'unknown') NOT NULL,
  number_engines ENUM('1', '2', '3', '4', 'unknown') NOT NULL, -- TODO: we were going to correct C here, I think
  large_aircraft ENUM('True', 'False', 'unknown') NOT NULL,
  );
  
-- assumption: we are assuming that each model for the airplane has only one engine configuration so we are correcting for it before uploading the table using a mean calculation. 
```

```{sql connection=mydb}
SELECT * FROM Aircraft;
```

## CREATE TABLE: State

```{sql connection=mydb}
DROP TABLE IF EXISTS State;
```

```{sql connection=mydb}
CREATE TABLE State(
  s_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  state VARCHAR(255) NOT NULL UNIQUE
  );
```

```{sql connection=mydb}
SELECT * FROM State;
```

## CREATE TABLE: Airport

```{sql connection=mydb}
DROP TABLE IF EXISTS Airport;
```

```{sql connection=mydb}
CREATE TABLE Airport(
  a_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  airport_name VARCHAR(255) NOT NULL,
  state INTEGER NOT NULL,
  CONSTRAINT state_fk FOREIGN KEY (state) REFERENCES State(s_id)
  );
```

```{sql connection=mydb}
SELECT * FROM Airport;
```

## CREATE TABLE: AirlineOperator

```{sql connection=mydb}
DROP TABLE IF EXISTS AirlineOperator;
```

```{sql connection=mydb}
CREATE TABLE AirlineOperator(
  ao_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  airline_name VARCHAR(255) NOT NULL UNIQUE
  );
```

```{sql connection=mydb}
SELECT * FROM AirlineOperator;
```

## CREATE TABLE: Flight

```{sql connection=mydb}
DROP TABLE IF EXISTS Flight;
```

```{sql connection=mydb}
CREATE TABLE Flight(
  f_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  flight_date DATETIME,
  aircraft_id INTEGER NOT NULL,
  origin_airport INTEGER NOT NULL,
  airline_operator INTEGER NOT NULL,
  CONSTRAINT aircraft_id_fk FOREIGN KEY (aircraft_id) REFERENCES Aircraft(a_id),
  CONSTRAINT origin_airport_fk FOREIGN KEY (origin_airport) REFERENCES Airport(a_id),
  CONSTRAINT airline_operator_fk FOREIGN KEY (airline_operator) REFERENCES AirlineOperator(ao_id),
  );
```

```{sql connection=mydb}
SELECT * FROM Flight;
```

## CREATE TABLE: Wildlife

```{sql connection=mydb}
DROP TABLE IF EXISTS Wildlife;
```

```{sql connection=mydb}
CREATE TABLE Wildlife(
  w_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  species VARCHAR(255) NOT NULL UNIQUE,
  size ENUM('Small', 'Medium', 'Large', 'unknown') 
  );
```

```{sql connection=mydb}
SELECT * FROM Wildlife;
```

## CREATE TABLE: Note

```{sql connection=mydb}
DROP TABLE IF EXISTS Note;
```

```{sql connection=mydb}
CREATE TABLE Note(
  n_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  note TEXT NOT NULL
  );
```

```{sql connection=mydb}
SELECT * FROM Note;
```

## CREATE TABLE: Birdstrike

```{sql connection=mydb}
DROP TABLE IF EXISTS Birdstrike;
```

```{sql connection=mydb}
CREATE TABLE Birdstrike(
  birdstrike_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  flight_id INTEGER NOT NULL,
  number_struck_est ENUM('1', '2 to 10', '11 to 100', '100+', 'Unknown') NOT NULL,
  number_struck_actual INTEGER NOT NULL,
  phase_of_flight ENUM('Approach', 'Climb', 'Descent', 'Landing Roll', 
                       'Parked', 'Take-off run', 'Taxi', 'Unknown') NOT NULL,
  altitude_bin ENUM('< 1000 ft', '> 1000 ft', 'Unknown' NOT NULL,
  impact_to_flight ENUM('Aborted Take-off', 'Engine Shut Down', 'None', 
                        'Other', 'Precautionary Landing', 'Unknown') NOT NULL,
  indicated_damage BOOLEAN NOT NULL,
  wildlife_remains_collected BOOLEAN NOT NULL,
  wildlife_remains_smithsonian BOOLEAN NOT NULL,
  note_id INTEGER,
  wildlife_id INTEGER NOT NULL,
  pilot_warned ENUM('True', 'False', 'Unknown') NOT NULL,
  total_cost INTEGER NOT NULL,
  feet_above_ground INTEGER NOT NULL,
  num_people_injured INTEGER NOT NULL,
  sky_conditions ENUM('No cloud', 'Overcast', 'Some cloud') NOT NULL,
  CONSTRAINT note_fk FOREIGN KEY (note_id) REFERENCES Note(n_id),
  CONSTRAINT wildlife_id_fk FOREIGN KEY (wildlife_id) REFERENCES Wildlife(w_id)
  );
```

```{sql connection=mydb}
SELECT * FROM Birdstrike;
```

## CREATE TABLE: Precipitation

```{sql connection=mydb}
DROP TABLE IF EXISTS Precipitation;
```

```{sql connection=mydb}
CREATE TABLE Precipitation(
  p_id INTEGER PRIMARY KEY AUTO_INCREMENT,
  precip_name ENUM('Fog', 'Rain', 'Snow', 'None') NOT NULL,
  birdstrike_id INTEGER NOT NULL,
  CONSTRAINT birdstrike_id_fk FOREIGN KEY (birdstrike_id) REFERENCES Birdstrike(birdstrike_id)
  );
```

```{sql connection=mydb}
SELECT * FROM Precipitation;
```

# Uploading the data

```{r}
## Needed to make sqldf work...learned that when fiddling
library(sqldf)
options(sqldf.driver = "SQLite")
```

## Load CSV File as DataFrame

```{r}
## Saved a copy of birdstrikes.csv to our git repo
file <- "BirdStrikesData.csv"

# to remove the blanks and update with UNKNOWN
birdStrike_df <- read.csv(file, header = TRUE, stringsAsFactors = FALSE, na.strings=c("", " "))
birdStrike_df[is.na(birdStrike_df)] <- 'UNKNOWN'
```

## Load CSV File as DataFrame >> THIS IS A TEST TO PULL IN rownumber, which we could possibly use to link everything together
```{r}
## Saved a copy of birdstrikes.csv to our git repo
file <- "BirdStrikesData.csv"

birdStrike_df_TEST <- read.csv(file, header = TRUE, stringsAsFactors = FALSE, na.strings=c("", " "))
birdStrike_df_TEST[is.na(birdStrike_df)] <- 'UNKNOWN'

setDT(birdStrike_df_TEST, keep.rownames = TRUE)[] # this isn't working on my machine for some reason
names(birdStrike_df_TEST)[names(birdStrike_df_TEST) == "rn"] <- "UniqueKey"
head(birdStrike_df_TEST)
```

```{r}
head(birdStrike_df)
```

# Cleaning the data

## Making factors

```{r}
## TODO: is this even something we want to use? Would a condition in the create table be better?

# aircraft table
birdStrike_df$'Aircraft: Type' <- as.factor(birdStrike_df$'Aircraft: Type')
birdStrike_df$'Aircraft: Number of engines' <- as.factor(birdStrike_df$'Aircraft: Number of engines')
birdStrike_df$'Is Aircraft Large?' <- as.factor(birdStrike_df$'Is Aircraft Large?')

# BirdStrike table
birdStrike_df$'Altitude bin' <- as.factor(birdStrike_df$'Altitude bin')
birdStrike_df$'Wildlife: Number struck' <- as.factor(birdStrike_df$'Wildlife: Number struck')
birdStrike_df$'Effect: Impact to flight' <- as.factor(birdStrike_df$'Effect: Impact to flight')
birdStrike_df$'Effect: Indicated Damage' <- as.factor(birdStrike_df$'Effect: Indicated Damage')
birdStrike_df$'When: Phase of flight' <- as.factor(birdStrike_df$'When: Phase of flight')
birdStrike_df$'Remains of wildlife collected' <- as.factor(birdStrike_df$'Remains of wildlife collected')
birdStrike_df$'Remains of wildlife send to Smithsonian' <- as.factor(birdStrike_df$'Remains of wildlife send to Smithsonian')
birdStrike_df$'Pilot warned of birds or wildlife' <- as.factor(birdStrike_df$'Pilot warned of birds or wildlife')

# Precipitation table
birdStrike_df$'Conditions: Precipitation' <- as.factor(birdStrike_df$'Conditions: Precipitation')

# Wildlife table
birdStrike_df$'Wildlife: Size' <- as.factor(birdStrike_df$'Wildlife: Size')

```

## PREPARE DATA: AirlineOperator

```{r}
AirlineOperatorTable <- sqldf('SELECT "Aircraft..Airline.Operator" AS airline_name 
                               FROM birdStrike_df')
head(AirlineOperatorTable)
```

## PREPARE DATA: State

```{r}
# Retrieve Data
StateTable <- sqldf('SELECT DISTINCT "Origin.State" AS state
                     FROM birdStrike_df
                     ORDER BY state')
head(StateTable)
```

```{r}
# Create query and upload
query <- sqlAppendTable(mydb, "State", StateData, row.names = FALSE) #TODO: should that be StateTable?
# can we consolidate these two above?
dbSendQuery(mydb, query)
```

## PREPARE DATA: Airport

```{r}
# Query State Data from Database
stateDataFromDatabase <- dbGetQuery(mydb, "SELECT * FROM State;")

# Join query from Database with query from birdStrike_df
stateDataTemp <- sqldf('SELECT DISTINCT "Airport..Name" AS airport_name
                       , s_id AS state_id
                       FROM csv
                       JOIN stateDataFromDatabase
                       ON "Origin.State" = state')

# Use SQLDF to query only columns needed, labeled as needed
airportData <- sqldf('SELECT DISTINCT airport_name
                     , state
                     FROM stateDataTemp
                     ORDER BY airport_name')

# I feel like for all of these we can remove the temp table state. Can we test out together?
```

```{r}
# TODO: this is not really important for anything, but could we put these chunks together?
query <- sqlAppendTable(mydb, "Airport", airportData, row.names = FALSE)
dbSendQuery(mydb, query)
```

## PREPARE DATA: Aircraft

Below we are finding the Mode of number_engines for each aircraft:

```{r}
# Query df to generate list of aircraft and numengines
AircraftNumEnginesOnlyDF <- sqldf('SELECT "Aircraft..Make.Model" AS Aircraft,
                                  "Aircraft..Number.of.engines." AS NumEngines
                                  FROM birdStrike_df
                                  ORDER BY Aircraft')
head(AircraftNumEnginesOnlyDF)
```

```{r}
# Create summary table and then convert it back to dataframe
AircraftNumEnginesOnlyTable <- table(AircraftNumEnginesOnlyDF)
head(AircraftNumEnginesOnlyTable)
```

```{r}
# Convert the table back to df
AircraftNumEnginesOnlyDF2 <- as.data.frame.matrix(AircraftNumEnginesOnlyTable)
head(AircraftNumEnginesOnlyDF2)
```

```{r}
# Find the max values for each column and add as new column
max_values <- colnames(AircraftNumEnginesOnlyDF2)[max.col(AircraftNumEnginesOnlyDF2, ties.method = "first")]
AircraftNumEnginesOnlyDF2$most_common_engine <- max_values
head(AircraftNumEnginesOnlyDF2)
```

```{r}
# Add airplane name as column, not row identifier
setDT(AircraftNumEnginesOnlyDF2, keep.rownames = TRUE)[]
head(AircraftNumEnginesOnlyDF2)
```

```{r}
# Query above table to retrieve needed format
AircraftTableEnginesOnly <- sqldf('SELECT rn AS name
                                  , most_common_engine AS number_engines 
                                  FROM AircraftNumEnginesOnlyDF2')
head(AircraftTableEnginesOnly)
```

```{r}
# Query dataframe to pull in large_aircraft attribute for each aircraft
AircraftTableLargeAircraft <- sqldf('SELECT DISTINCT "Aircraft..Make.Model" AS name,
                                    "Aircraft..Type" AS aircraft_type,
                                    "Is.Aircraft.Large." AS large_aircraft
                                    FROM birdStrike_df
                                    GROUP BY name')
head(AircraftTableLargeAircraft)
```

```{r}
# Union df that has engine setup with df that has aircraft_type and large_aircraft
AircraftTable <- sqldf('SELECT rest.name
                       , rest.aircraft_type
                       , engines.number_engines
                       , rest.large_aircraft
                       FROM AircraftTableLargeAircraft AS rest
                       JOIN AircraftTableEnginesOnly AS engines
                       ON rest.name = engines.name
                       ORDER BY rest.name')
head(AircraftTable)
```

```{r}
# TODO: this is not really important for anything, but could we put these chunks together?
query <- sqlAppendTable(mydb, "Aircraft", AircraftTable, row.names = FALSE)
dbSendQuery(mydb, query)
```

## PREPARE DATA: Note

```{r}
NoteData <- sqldf('SELECT DISTINCT "Remarks" AS note
                       FROM birdStrike_df')


# I feel like for all of these we can remove the temp table state. Can we test out together?
```

```{r}
# TODO: this is not really important for anything, but could we put these chunks together?
query <- sqlAppendTable(mydb, "Note", NoteData, row.names = FALSE)
dbSendQuery(mydb, query)
```

## PREPARE DATA: Wildlife

```{r}
WildlifeData <- sqldf('SELECT DISTINCT "Wildlife..Species" AS species
                  , "Wildlife..Size" as size
                  FROM birdStrike_df')


# I feel like for all of these we can remove the temp table state. Can we test out together?
```

```{r}
# TODO: this is not really important for anything, but could we put these chunks together?
query <- sqlAppendTable(mydb, "Note", WildlifeData, row.names = FALSE)
dbSendQuery(mydb, query)
```

## Practicum Questions

4. (10 pts / 1 hr) Create a SQL query against your database to find the number of bird strike incidents for each airline upon take-off or climb. Include all airlines. You may either use a {sql} code chunk or an R function to execute the query.

```{sql connection=mydb}
SELECT SUM(BirdStrike.birdstrike_id) as incidents
, airline_operator
FROM BirdStrike
JOIN Flight
ON BirdStrike.flight_id = Flight.f_id
WHERE phase_of_flight = ('Take-off run' OR 'Climb')
GROUP BY airline_operator
```

5. (10 pts / 1 hr) Create a SQL query against your database to find the airports that had the most bird strike incidents (during any flight phase). Include all airlines. You may either use a {sql} code chunk or an R function to execute the query.

```{sql connection=mydb}
SELECT TOP 10 SUM(BirdStrike.birdstrike_id) as incidents
, origin_airport
FROM BirdStrike
JOIN Flight
ON BirdStrike.flight_id = Flight.f_id
GROUP BY origin_airport
ORDER BY incidents desc
```

6. (10 pts / 1 hr) Create a SQL query against your database to find the number of bird strike incidents by year. Include all airlines. You may either use a {sql} code chunk or an R function to execute the query.

```{sql connection=mydb}
SELECT SUM(BirdStrike.birdstrike_id) as incidents
, YEAR(Flight.flight_date) as Year
FROM BirdStrike
JOIN Flight
ON BirdStrike.flight_id = Flight.f_id
GROUP BY YEAR(Flight.flight_date)
```

7. (10 pts / 3 hrs) Using the above data, build a column chart that visualizes the number of bird strikes incidents per year from 2008 to 2011 during take-off/climbing and during descent/approach/landing. Adorn the graph with appropriate axis labels.

```{sql connection=mydb}

```

8. (10 pts / 3 hrs) Create a stored procedure in MySQL (note that if you used SQLite, then you cannot complete this step) that removes a bird strike incident from the database. You may decide what you need to pass to the stored procedure to remove a bird strike incident, e.g., departure airport, airlines, or some ID. Show that the deletion worked as expected.

```{sql connection=mydb}

```

## Disconnect 

```{r}
dbDisconnect(mydb)
```
